/*
 * This code came from OpenCV
 * I just had ported OpenCV code as my need
 */

#include "resize.h"

namespace ycv{

const size_t MAX_ESIZE = 16;
const int INTER_RESIZE_COEF_BITS=11;
const int INTER_RESIZE_COEF_SCALE=1 << INTER_RESIZE_COEF_BITS;

void ResizeGeneric(	const YMat<unsigned char> &src,
					YMat<unsigned char> &dst,
					const int* xofs, const void* _alpha,
					const int* yofs, const void* _beta,
					int xmin, int xmax, int ksize )
{
    //typedef typename HResize::alpha_type AT;
    //const AT* beta = (const AT*)_beta;
	//Size ssize = src.size(), dsize = dst.size();

	int src_width = src.GetWidth();
	int src_height = src.GetHeight();
	int num_channels = src.GetChannels();
	int dst_width = dst.GetWidth();
	int dst_height = dst.GetHeight();

	int cn = num_channels;
	src_width = src_width * cn;
	dst_width = dst_width * cn;

    xmin = xmin * cn;
    xmax = xmax * cn;
    // image resize is a separable operation. In case of not too strong

//    Range range(0, dsize.height);
//    resizeGeneric_Invoker<HResize, VResize> invoker(src, dst, xofs, yofs, (const AT*)_alpha, beta,
//        ssize, dsize, ksize, xmin, xmax);
//    parallel_for_(range, invoker, dst.total()/(double)(1<<16));

    int dy;
    const int align_n = 16;
    int bufstep = (dst_width+align_n-1) & (-align_n);
    std::vector<int> buffer;
    buffer.reserve(bufstep*ksize);
    const int* srows[MAX_ESIZE] = {0, };
    int* rows[MAX_ESIZE] = {0, };



}

void Resize(const YMat<unsigned char> &src, YMat<unsigned char> &dst, YSize size=YSize(0, 0))
{
	int src_width = src.GetWidth();
	int src_height = src.GetHeight();
	int num_channels = src.GetChannels();

	assert(num_channels==1 && "Only resizing 1 channel images is implemented");

	if(size == YSize(0, 0)){
		dst = YMat<T>(size.GetW(), size.GetH(), num_channels);
	}

	int dst_width = dst.GetWidth();
	int dst_height = dst.GetHeight();

	float inv_scale_x = (float)dst_width/src_width;
	float inv_scale_y = (float)dst_height/src_height;

	const int depth = 0;
	const int cn = 1;
	const float scale_x = 1./inv_scale_x;
	const float scale_y = 1./inv_scale_y;

	int xmin = 0;
	int xmax = dst_width;
	int width = dst_width * cn;

	int ksize = 2;
	int ksize2 = 1;

	std::vector<unsigned char> buffer;
	buffer.reserve((width+dst_height)*(sizeof(int)+sizeof(float)*ksize));


	const bool fixpt = true;
	int* xofs = (int*)(unsigned char*)&buffer[0];
	int* yofs = xofs + width;
	float* alpha = (float*)(yofs + dst_height);
	short* ialpha = (short*)alpha;
	float* beta = alpha + width*ksize;
	short* ibeta = ialpha + width*ksize;
	float cbuf[MAX_ESIZE];

	float fx, fy;
    int sx, sy;

	for(int dx=0;dx<dst_width;dx++){
		fx = (float)((dx+0.5)*scale_x - 0.5);
		sx = std::floor(fx);
		fx = fx - sx;

		if( sx < ksize2-1 ){
			xmin = dx + 1;
			if( sx < 0 ){
				fx = 0;
				sx = 0;
			}
		}
		if( sx + ksize2 >= src_width ){
			xmax = std::min( xmax, dx);
			if( sx >= src_width - 1){
				fx = 0;
				sx = src_width - 1;
			}
		}

		sx = sx*cn;
		for(int k=0; k<cn; k++){
			xofs[dx*cn + k] = sx + k;
		}

		cbuf[0] = 1.f-fx;
		cbuf[1] = fx;

        if( fixpt ){
        	int k;
            for(k = 0; k < ksize; k++ )
                ialpha[dx*cn*ksize + k] = saturate_cast<short>(cbuf[k]*INTER_RESIZE_COEF_SCALE);
            for( ;k < cn*ksize; k++ )
                ialpha[dx*cn*ksize + k] = ialpha[dx*cn*ksize + k - ksize];
        }
        else{
        	int k;
            for(k = 0; k < ksize; k++ ){
                alpha[dx*cn*ksize + k] = cbuf[k];
            }
            for( ;k < cn*ksize; k++ ){
                alpha[dx*cn*ksize + k] = alpha[dx*cn*ksize + k - ksize];
            }
        }
	}

    for(int dy = 0; dy < dsize.height; dy++ )
    {
		fy = (float)((dy+0.5)*scale_y - 0.5);
		sy = std::floor(fy);
		fy -= sy;

        yofs[dy] = sy;
		cbuf[0] = 1.f - fy;
		cbuf[1] = fy;

        if( fixpt )
        {
            for( k = 0; k < ksize; k++ ){
                ibeta[dy*ksize + k] = saturate_cast<short>(cbuf[k]*INTER_RESIZE_COEF_SCALE);
            }
        }
        else
        {
            for( k = 0; k < ksize; k++ ){
                beta[dy*ksize + k] = cbuf[k];
            }
        }
    }

}



}
