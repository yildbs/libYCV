#include "resize.h"

namespace ycv{


template <typename T>
void Resize(YMat<T> &src, YMat<T> &dst, YSize size=YSize(0, 0))
{
	int src_width = src.GetWidth();
	int src_height = src.GetHeight();
	int num_channels = src.GetChannels();

	assert(num_channels==1 && "Only resizing 1 channel images is implemented");

	if(size == YSize(0, 0)){
		dst = YMat<T>(size.GetW(), size.GetH(), num_channels);
	}

	int dst_width = dst.GetWidth();
	int dst_height = dst.GetHeight();

	float inv_scale_x = (float)dst_width/src_width;
	float inv_scale_y = (float)dst_height/src_height;

	const int depth = 0;
	const int cn = 1;
	const float scale_x = 1./inv_scale_x;
	const float scale_y = 1./inv_scale_y;

	const int xmin = 0;
	const int xmax = dst_width;
	const int width = dst_width * cn;

	int ksize = 2;
	int ksize2 = 1;

	std::vector<unsigned char> buffer;
	buffer.reserve((width+dst_height)*(sizeof(int)+sizeof(float)*ksize));

	const size_t MAX_ESIZE = 16;
	int* xofs = (int*)(unsigned char*)&buffer[0];
	int* yofs = xofs + width;
	float* alpha = (float*)(yofs + dst_height);
	short* ialpha = (short*)alpha;
	float* beta = alpha + width*ksize;
	short* ibeta = ialpha + width*ksize;
	float cbuf[MAX_ESIZE];

	float fx, fy;

	for(int dx=0;dx<dst_width;dx++){
		fx = 0;
	}
}



}
