#include "resize.h"

namespace ycv{


template <typename T>
void Resize(YMat<T> &src, YMat<T> &dst, YSize size=YSize(0, 0))
{
	int src_width = src.GetWidth();
	int src_height = src.GetHeight();
	int num_channels = src.GetChannels();

	assert(num_channels==1 && "Only resizing 1 channel images is implemented");

	if(size == YSize(0, 0)){
		dst = YMat<T>(size.GetW(), size.GetH(), num_channels);
	}

	int dst_width = dst.GetWidth();
	int dst_height = dst.GetHeight();

	float inv_scale_x = (float)dst_width/src_width;
	float inv_scale_y = (float)dst_height/src_height;

	const int depth = 0;
	const int cn = 1;
	const float scale_x = 1./inv_scale_x;
	const float scale_y = 1./inv_scale_y;

	int xmin = 0;
	int xmax = dst_width;
	int width = dst_width * cn;

	int ksize = 2;
	int ksize2 = 1;

	std::vector<unsigned char> buffer;
	buffer.reserve((width+dst_height)*(sizeof(int)+sizeof(float)*ksize));

	const size_t MAX_ESIZE = 16;
	int* xofs = (int*)(unsigned char*)&buffer[0];
	int* yofs = xofs + width;
	float* alpha = (float*)(yofs + dst_height);
	short* ialpha = (short*)alpha;
	float* beta = alpha + width*ksize;
	short* ibeta = ialpha + width*ksize;
	float cbuf[MAX_ESIZE];

	float fx, fy;
    int sx, sy;

	for(int dx=0;dx<dst_width;dx++){
		fx = (float)((dx+0.5)*scale_x - 0.5);
		sx = std::floor(fx);
		fx = fx - sx;

		if( sx < ksize2-1 ){
			xmin = dx + 1;
			if( sx < 0 ){
				fx = 0;
				sx = 0;
			}
		}
		if( sx + ksize2 >= src_width ){
			xmax = std::min( xmax, dx);
			if( sx >= src_width - 1){
				fx = 0;
				sx = src_width - 1;
			}
		}

		sx = sx*cn;
		for(int k=0; k<cn; k++){
			xofs[dx*cn + k] = sx + k;
		}

		cbuf[0] = 1.f-fx;
		cbuf[1] = fx;

	}
}



}
